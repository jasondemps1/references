#+TITLE: Common Lisp LOOP Macro Quick Reference
#+STARTUP: overview
#+PROPERTY: header-args:lisp :exports code :eval no
#+OPTIONS: toc:nil num:nil

[[file:index.org][← Common Lisp]] | [[file:../index.org][← Index]]

A practical reference for the extended LOOP macro. Keywords can be symbols (~for~) or keywords (~:for~)—they're equivalent.

* Variable Iteration (for/as)

~for~ and ~as~ are interchangeable.

** Lists

#+begin_src lisp
;; Iterate over elements
(loop for x in '(1 2 3) collect (* x x))        ; => (1 4 9)

;; Iterate over cons cells (sublists)
(loop for x on '(1 2 3) collect x)              ; => ((1 2 3) (2 3) (3))

;; Destructuring
(loop for (a b) in '((1 2) (3 4)) collect (+ a b))  ; => (3 7)

;; With step (cddr instead of cdr)
(loop for x in '(1 2 3 4 5 6) by #'cddr collect x)  ; => (1 3 5)
#+end_src

** Numeric Ranges

#+begin_src lisp
(loop for i from 0 to 5 collect i)              ; => (0 1 2 3 4 5)  [inclusive]
(loop for i from 0 below 5 collect i)           ; => (0 1 2 3 4)    [exclusive]
(loop for i from 5 downto 0 collect i)          ; => (5 4 3 2 1 0)
(loop for i from 5 above 0 collect i)           ; => (5 4 3 2 1)
(loop for i from 0 to 10 by 2 collect i)        ; => (0 2 4 6 8 10)
(loop for i from 10 downto 0 by 3 collect i)    ; => (10 7 4 1)

;; Shorthand: upfrom/downfrom
(loop for i upfrom 0 to 3 collect i)            ; => (0 1 2 3)
(loop for i downfrom 5 to 2 collect i)          ; => (5 4 3 2)
#+end_src

*Keywords*: ~from~, ~to~, ~below~, ~above~, ~downto~, ~upto~, ~by~, ~upfrom~, ~downfrom~

** Vectors/Strings

#+begin_src lisp
(loop for c across "hello" collect c)           ; => (#\h #\e #\l #\l #\o)
(loop for x across #(1 2 3) sum x)              ; => 6
#+end_src

** Computed Values

#+begin_src lisp
;; Single expression (re-evaluated each iteration)
(loop for x = (random 10) repeat 3 collect x)   ; => (7 2 9) [random]

;; Initial + step expression
(loop for x = 0 then (1+ x) repeat 5 collect x) ; => (0 1 2 3 4)

;; Fibonacci example
(loop for a = 0 then b
      for b = 1 then (+ a b)
      repeat 10 collect a)                       ; => (0 1 1 2 3 5 8 13 21 34)
#+end_src

** Hash Tables

#+begin_src lisp
(loop for k being the hash-keys of ht collect k)
(loop for v being the hash-values of ht collect v)
(loop for k being the hash-keys of ht using (hash-value v)
      collect (cons k v))
(loop for v being the hash-values of ht using (hash-key k)
      collect (list k v))
#+end_src

** Packages

#+begin_src lisp
(loop for sym being the symbols of :cl-user collect sym)
(loop for sym being the present-symbols of :my-package collect sym)
(loop for sym being the external-symbols of :cl collect sym)
#+end_src

** Parallel vs Sequential

#+begin_src lisp
;; Parallel (both advance together, stops at shortest)
(loop for x in '(a b c)
      for y in '(1 2 3 4 5)
      collect (list x y))                        ; => ((A 1) (B 2) (C 3))

;; Sequential (and)
(loop for x in '(a b)
      and y in '(1 2)
      collect (list x y))                        ; same behavior, but bound simultaneously
#+end_src

* Accumulation Clauses

All accumulation clauses support ~into var~ to accumulate into a named variable.

#+begin_src lisp
;; Collecting
(loop for i from 1 to 3 collect i)               ; => (1 2 3)
(loop for i from 1 to 3 collect i into result
      finally (return (nreverse result)))        ; manual control

;; Appending/Nconcing lists
(loop for x in '((1 2) (3 4)) append x)          ; => (1 2 3 4)  [copies]
(loop for x in '((1 2) (3 4)) nconc x)           ; => (1 2 3 4)  [destructive]

;; Counting
(loop for x in '(1 2 nil 3 nil) count x)         ; => 3
(loop for x in '(1 2 3 4 5) count (evenp x))     ; => 2

;; Summing
(loop for x in '(1 2 3 4 5) sum x)               ; => 15
(loop for x in '(1 2 3) sum (* x x))             ; => 14

;; Min/Max
(loop for x in '(3 1 4 1 5) maximize x)          ; => 5
(loop for x in '(3 1 4 1 5) minimize x)          ; => 1

;; Multiple accumulators
(loop for x in '(1 2 3 4 5)
      sum x into total
      count (oddp x) into odds
      finally (return (list total odds)))        ; => (15 3)
#+end_src

*Keywords*: ~collect~, ~append~, ~nconc~, ~count~, ~sum~, ~maximize~, ~minimize~, ~into~

* Termination Clauses

#+begin_src lisp
;; Fixed iterations
(loop repeat 5 collect 'x)                       ; => (X X X X X)

;; While/Until (tested at start of iteration)
(loop for x in '(1 2 3 nil 5 6)
      while x collect x)                         ; => (1 2 3)
(loop for x in '(1 2 3 nil 5 6)
      until (null x) collect x)                  ; => (1 2 3)

;; Always/Never (return T/NIL, short-circuit on failure)
(loop for x in '(2 4 6) always (evenp x))        ; => T
(loop for x in '(2 3 6) always (evenp x))        ; => NIL
(loop for x in '(2 4 6) never (oddp x))          ; => T

;; Thereis (return first truthy value or NIL)
(loop for x in '(1 2 3 4) thereis (and (evenp x) x))  ; => 2
#+end_src

*Keywords*: ~repeat~, ~while~, ~until~, ~always~, ~never~, ~thereis~

* Conditionals

#+begin_src lisp
;; when/if (synonymous)
(loop for x from 1 to 10 when (evenp x) collect x)    ; => (2 4 6 8 10)

;; unless
(loop for x from 1 to 10 unless (evenp x) collect x)  ; => (1 3 5 7 9)

;; if/else/end
(loop for x from 1 to 5
      if (evenp x)
        collect x into evens
      else
        collect x into odds
      end
      finally (return (list evens odds)))             ; => ((2 4) (1 3 5))

;; Multiple actions (use and)
(loop for x from 1 to 5
      when (evenp x)
        collect x into evens
        and sum x into even-sum
      finally (return (list evens even-sum)))         ; => ((2 4) 6)
#+end_src

*Keywords*: ~if~, ~when~, ~unless~, ~else~, ~end~, ~and~

* Unconditional Execution

#+begin_src lisp
;; do (execute forms)
(loop for x from 1 to 3 do (print x))            ; prints 1 2 3, returns NIL

;; Multiple forms
(loop for x in '(1 2 3)
      do (format t "~a " x)
         (force-output))

;; initially (before loop starts)
(loop initially (print "Starting!")
      for x from 1 to 3 collect x)

;; finally (after loop ends, but before return)
(loop for x from 1 to 3 collect x
      finally (print "Done!"))

;; finally with return
(loop for x in '(1 2 3) sum x into total
      finally (return (* total 2)))              ; => 12
#+end_src

*Keywords*: ~do~, ~doing~, ~initially~, ~finally~, ~return~

* Named Loops & Early Exit

#+begin_src lisp
;; Named loop for nested escape
(loop named outer
      for x from 1 to 10
      do (loop for y from 1 to 10
               when (> (* x y) 50)
                 do (return-from outer (list x y))))  ; => (6 9)

;; Return clause vs return form
(loop for x in '(1 2 3)
      when (= x 2) return :found)                ; => :FOUND

(loop for x in '(1 2 3)
      when (= x 2) do (return :found))           ; => :FOUND (equivalent)
#+end_src

*Keywords*: ~named~, ~return~

* Binding & Assignment

#+begin_src lisp
;; with (like let*)
(loop with a = 1
      with b = (1+ a)
      for i from 1 to 3
      collect (+ a b i))                         ; => (4 5 6)

;; Multiple with bindings
(loop with (a b) = '(1 2)                        ; destructuring
      return (+ a b))                            ; => 3

;; Type declarations
(loop with sum fixnum = 0
      for x fixnum in '(1 2 3)
      do (incf sum x)
      finally (return sum))
#+end_src

*Keywords*: ~with~, ~=~

* Type Declarations

#+begin_src lisp
(loop for i fixnum from 0 to 100 sum i)
(loop for x float in float-list sum x)
(loop for c character across "hello" collect c)
(loop for item t in mixed-list collect item)     ; t = any type
#+end_src

*Types*: ~fixnum~, ~float~, ~t~, ~nil~, ~character~, ~vector~, ~list~, and any CL type

* Quick Pattern Reference

| Pattern       | Example                                 |
|---------------+-----------------------------------------|
| Iterate list  | ~for x in list~                         |
| Iterate cdrs  | ~for x on list~                         |
| Numeric range | ~for i from 0 to n~                     |
| Exclusive end | ~for i from 0 below n~                  |
| Count down    | ~for i from n downto 0~                 |
| Vector/string | ~for x across vec~                      |
| Computed      | ~for x = init then step~                |
| Hash keys     | ~for k being the hash-keys of ht~       |
| Hash values   | ~for v being the hash-values of ht~     |
| Parallel      | ~for x in xs for y in ys~               |
| Fixed count   | ~repeat n~                              |
| Conditional   | ~when cond collect x~                   |
| Multi-accum   | ~collect x into xs sum y into total~    |
| Early exit    | ~when cond return value~                |
| Named exit    | ~named foo ... return-from foo~         |

* Common Gotchas

1. *Termination order*: ~while~/~until~ test /before/ the body; put them after iterators
2. *Parallel iteration*: Multiple ~for~ clauses iterate in parallel and stop at the shortest
3. *Return value*: Without accumulation, ~loop~ returns ~NIL~; ~always~/~never~ return ~T~ or ~NIL~
4. *finally return*: Must use ~(return x)~ form, not just ~x~
5. *Destructuring*: Works with ~for (a b) in list~ and ~with (a b) = expr~
6. *across vs in*: ~across~ is for vectors/strings; ~in~ is for lists
7. *thereis*: Returns the actual truthy value, not just ~T~

* Full Keyword List

** Iteration
~for~, ~as~, ~in~, ~on~, ~across~, ~being~, ~the~, ~hash-keys~, ~hash-values~, ~of~, ~using~, ~symbols~, ~present-symbols~, ~external-symbols~, ~from~, ~to~, ~below~, ~above~, ~downto~, ~upto~, ~upfrom~, ~downfrom~, ~by~, ~=~, ~then~

** Binding
~with~

** Accumulation
~collect~, ~collecting~, ~append~, ~appending~, ~nconc~, ~nconcing~, ~count~, ~counting~, ~sum~, ~summing~, ~maximize~, ~maximizing~, ~minimize~, ~minimizing~, ~into~

** Termination
~repeat~, ~while~, ~until~, ~always~, ~never~, ~thereis~

** Conditional
~if~, ~when~, ~unless~, ~else~, ~end~, ~and~

** Execution
~do~, ~doing~, ~initially~, ~finally~, ~return~

** Naming
~named~
